
简单的五子棋AI：
1、实现了极大值极小值搜索 
1、加了AI走一步的时间计算,增加alpha、beta的裁剪,效果一般,勉强算到4步(10s内)。
缺陷：仍采用输入坐标的形式（比如 1，2 表示在坐标1，2 处下棋；）

    定义头文件 wuziqi_types.h

使用#ifndef 进行操作
定义     正常走子GO_OK 为0  
         错误走子GO_ERROR为-1 
         走子胜利GO_WIN为1
用typedef重命名 unsigned char、signed char 等数据类型，
方便读写代码

    定义头文件 wuziqi2_main.h

定义棋盘大小 15
定义搜索层数 4
定义函数 check(x) 检查棋盘是否越界
定义 空格为0  白棋为1  黑棋为2

定义得分板（枚举类型）：
WIN5 = 100000,          //5连           
ALIVE4 = 10000,         //活4
ALIVE3 = 1000,        //活3
DIE4 = 1000,           //死4
ALIVE2 = 100,         //活2
DIE3 = 100,             //死3
DIE2 = 10,               //死2
ALIVE1 = 10            //活1

定义棋盘棋子坐标，一个结构，里面有两个unsigned char 类型表示当前棋盘坐标x,y;
定义空子的序列：一个容量为225的结构数组（棋子坐标），储存信息表示棋盘该坐标状态；


    主函数：
1、实现了极大值极小值搜索 
1、加了AI走一步的时间计算,增加alpha、beta的裁剪,效果一般,勉强算到4步(10s内)。
缺陷：仍采用输入坐标的形式（比如 1，2 表示在坐标1，2 处下棋；）


具体程序解释：

全局变量：
1.棋盘表示：15*15的二维数组；
2.AI棋颜色；
3.人玩家棋颜色；
4.搜索层数；

静态函数：
1.初始化棋盘；
2.极大值层；
3.极小值层；
4.极大值极小值算法；
5.玩家下棋；
6.AI下棋；
7.局势评估；
8.赢棋检测；
9.打印棋盘；
10.计分函数；

主函数：
1.棋子数量（统计；和棋盘最大落子数量比较（平局））；
2.人机交互，提醒玩家下棋；
3.初识化棋盘；
4.进入循环函数：
  1）判断黑棋白棋决定先手后手
  2）读取坐标下棋；
    1-根据玩家下棋/AI下棋函数的返回值（每下一步棋，下棋函数内都有赢棋检测函数，它会检测下了这步棋后是否能达成胜利条件，并返回一个值），判断是否达成胜利条件；
    2-下棋函数内，如果输入落子坐标不合法（越界：数字为负值或超过15；），需要重新输入；
    3-输入字母（scanf（）函数报错）退出程序；
  3）循环；

函数细节：
1.玩家下棋：
    玩家输入坐标，读取后将棋盘二维数组相应值赋1，然后判断是否胜利（赢棋检测），打印棋盘；
2.AI下棋：
    如果AI先手，随机一个中间的棋子；
    AI后手：1.打印“Waiting AI…”人机交互；
        2.记录程序此刻时间；
        3.运行极大值极小值搜索算法（运用alpha、beta的裁剪，效果一般，四层）；
        4.记录程序结束时间，并相减得到搜索算法运行时间；
        5.打印AI花费时间、赢棋检测函数判断是否胜利（返回值）、打印棋盘；
3.初始化棋盘，打印棋盘：根据棋盘的二维数组遍历打印；
4.判断是否胜利：
    当下一个棋子的时候（对应相应的棋盘应该有一个坐标），判断下的棋子的横行或竖行或斜行（左斜与右斜）是否满足连续棋子的个数大于等于5个，（横行，竖行，左斜，右斜）进行遍历。
    横竖遍历：从当前落子位置出发：for (j=(y-4>0?y-4:0); (j<=y+4)&&(j<size); j++) ；
    斜行遍历：从当前落子位置出发：for (i=x-4,j=y-4;(i>=0)&&(i<=x+4)&&(i<size)&&(j>=0)&&(j<=y+4)&&(j<size); i++,j++) ；
5.计分函数：
    1.根据连子个数和两段空子个数，返回分数（根据头文件1中的定义得分）；
    读取一个一维数组、一个代表玩家/AI的整数，遍历一维数组取到同色棋数目、异色棋数目、空白处，通过棋数（number）、空白（empty）两个整数判断活三、活二等；
6.评估函数：
    1.首先定义包含15个unsigned char类型的数组，依次记录每一横排、纵排、斜排的落子情况；
    2.用积分函数读取每一次数组，得到每一个分数（返回值）；
    3.分别累加得到人、机得分，返回总分差（AI得分-玩家得分），局势判断结束；
7.判断是否有邻居：仅判断两步以内是否有子（简单的遍历）；
8.产生空子序列：方便极大值层、极小值层的编写；
9.极大值极小值的最优解以及alpha -beta剪枝：
对max和min函数都增加一个 alpha 和 beta 参数。在 max 函数中如果发现一个子节点的值大于 alpha，则不再计算后序节点，此为 Alpha 剪枝。在 min 函数中如果发现一个子节点的值小于 beta，则不再计算后序节点，此为 Beta剪枝。



参考https://blog.csdn.net/qq_27008079/article/details/60869054 https://blog.csdn.net/lihongxun945/article/details/50668253

